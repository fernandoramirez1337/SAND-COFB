# SAND128 C Implementation

This repository provides a C99 implementation of the SAND128 block cipher. The project includes a static library for the cipher, a comprehensive test and benchmarking executable, and a Dockerfile for easy containerization.

The implementation is bitsliced and operates in Electronic Codebook (ECB) mode.

## Repository Structure

```
.
├── CMakeLists.txt              # Build script for CMake
├── Dockerfile                  # Dockerfile for containerized build and execution
├── SAND.c                      # Source file for the SAND128 cipher logic
├── SAND.h                      # Header file for the SAND128 cipher
├── main.c                      # Main executable for testing and benchmarking
├── gen_data.py                 # Python script to generate test data files
├── data/                         # Directory for test data (generated by gen_data.py)
│   ├── data_random.bin
│   ├── data_zeros.bin
│   └── ...
└── build/                        # Build output directory (created by CMake)
```

## Prerequisites

To build and run this project locally, you will need:

- `gcc` (or another C99-compliant C compiler)
- `cmake` (version 3.10 or higher)
- `make`
- `python3` (for generating test data)

## Building and Running

### 1. Generate Test Data

First, run the Python script to generate the binary data files used for testing and benchmarking. These files will be placed in the `data/` directory.

```bash
python3 gen_data.py
```

### 2. Compile the Project

Use CMake to build the project. The compiled executable `sand_bench` will be placed in the `build/` directory.

```bash
mkdir -p build
cd build
cmake ..
make
```

### 3. Run the Executable

Execute the `sand_bench` program from the `build` directory. It performs two main tasks:

1. **Consistency Tests**: Encrypts and decrypts data using various keys to ensure the output matches the original input.
2. **Performance Benchmarks**: Measures the throughput and latency of the encryption and decryption operations.

By default, it uses `data/data_random.bin`.

```bash
./sand_bench
```

You can also specify a different data file as a command-line argument:

```bash
./sand_bench ../data/data_zeros.bin
```

## Docker Usage

A `Dockerfile` is provided for building and running the project in a containerized environment.

### 1. Build the Docker Image

From the root of the repository, run the following command:

```bash
docker build -t sand128-bench .
```

### 2. Run the Container

Run the benchmark executable inside the container. The `Dockerfile` includes steps to generate data and compile the project.

```bash
docker run --rm sand128-bench
```

To run the benchmark with a different data file, you can override the default command:

```bash
docker run --rm sand128-bench /app/build/sand_bench /app/data/data_pattern_aa.bin
```

## Functionality Details

### `sand` Library (`SAND.c`, `SAND.h`)

- Implements the SAND128 block cipher with a 128-bit block size and a 128-bit key size.
- The implementation is **bitsliced**, which allows for efficient processing of multiple blocks in parallel.
- The primary encryption function `ECB_encrypt_Bitslice` operates in **Electronic Codebook (ECB)** mode.
- Includes a `KeySchedule` function to generate round keys from a master key.

### `sand_bench` Executable (`main.c`)

- **Consistency Testing**:
  - Runs multiple test scenarios with different keys (a reference key, an all-zeros key) and data sizes.
  - For each scenario, it encrypts data and then decrypts it, verifying that the result is identical to the original plaintext.
  - It reports `PASS` or `FAIL` for each test.

- **Performance Benchmarking**:
  - Measures the execution time for key generation, encryption, and decryption.
  - Reports performance metrics, including:
    - **Total Execution Time** (in microseconds and seconds).
    - **Throughput** (in MB/s).
    - **Latency per Block** (in µs/block).
